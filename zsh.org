#+startup: content
* zshrc
:PROPERTIES:
:header-args: :tangle ~/.config/zsh/.zshrc
:END:

put common headers in just one file? tangle org mode...
https://github.com/zimfw/completion/blob/master/init.zsh
zmodload -F zsh/datetime +p:EPOCHREALTIME

https://grml.org/zsh/zsh-lovers.html#_aliases
http://www.acm.uiuc.edu/workshops/zsh/alias.html

https://github.com/glacambre/ileum

autoload -Uz promptinit && promptinit
# prompt adam1  # Or any theme

#allow tab completion in the middle of a word
setopt COMPLETE_IN_WORD

## keep background processes at full speed
#setopt NOBGNICE
## restart running processes on exit
#setopt HUP


## never ever beep ever
#setopt NO_BEEP

## automatically decide when to page a list of completions
#LISTMAX=0

## disable mail checking
#MAILCHECK=0

# autoload -U colors
#colors
** [[https://github.com/zimfw/environment/blob/master/init.zsh][Options]]
#+begin_src zsh
setopt CORRECTALL
#+end_src
# magicequalsubst
# nonomatch
# notify
# numericglobsort
# promptsubst

## history
#setopt APPEND_HISTORY
## for sharing history between zsh processes
#setopt INC_APPEND_HISTORY
#setopt SHARE_HISTORY

Generic options and environment settings

*** Changing directories
#+begin_src zsh

# Perform cd to a directory if the typed command is invalid, but is a directory.
setopt AUTO_CD

# Make cd push the old directory to the directory stack.
setopt AUTO_PUSHD

autoload -Uz is-at-least && if is-at-least 5.8; then
    # Don't print the working directory after a cd.
    setopt CD_SILENT
fi

# Don't push multiple copies of the same directory to the stack.
setopt PUSHD_IGNORE_DUPS

# Don't print the directory stack after pushd or popd.
setopt PUSHD_SILENT

# Have pushd without arguments act like `pushd ${HOME}`.
setopt PUSHD_TO_HOME

#+end_src

*** Expansion and globbing
#+begin_src zsh
# Treat `#`, `~`, and `^` as patterns for filename globbing.
setopt EXTENDED_GLOB

# Pass through unmatched patterns like Bash (instead of failing)
setopt NO_NOMATCH
#+end_src

*** History
 #+begin_src zsh
 # The file to save the history in.
 if (( ! ${+HISTFILE} )) typeset -g HISTFILE=${ZDOTDIR:-${HOME}}/.zhistory

    # The maximum number of events stored internally and saved in the history file.
    # The former is greater than the latter in case user wants HIST_EXPIRE_DUPS_FIRST.
    HISTSIZE=20000
    SAVEHIST=10000

    # Don't display duplicates when searching the history.
    setopt HIST_FIND_NO_DUPS

    # Don't enter immediate duplicates into the history.
    setopt HIST_IGNORE_DUPS

    # Remove commands from the history that begin with a space.
    setopt HIST_IGNORE_SPACE

    # Execute the command directly upon history expansion.
    unsetopt HIST_VERIFY

    # Cause all terminals to share the same history 'session'.
    setopt SHARE_HISTORY
 #+end_src

*** Input/output
 #+begin_src zsh
 # Allow comments starting with `#` in the interactive shell.
 setopt INTERACTIVE_COMMENTS

 # Disallow `>` to overwrite existing files. Use `>|` or `>!` instead.
 setopt NO_CLOBBER
 #+end_src

*** Job control
 #+begin_src zsh
 # List jobs in verbose format by default.
 setopt LONG_LIST_JOBS

 # Prevent background jobs being given a lower priority.
 setopt NO_BG_NICE

 # Prevent status report of jobs on shell exit.
 setopt NO_CHECK_JOBS

 # Prevent SIGHUP to jobs on shell exit.
 setopt NO_HUP
 #+end_src

** zinit
*** Bootstrap
#+begin_src zsh
### Added by Zinit's installer
if [[ ! -f $HOME/.local/share/zinit/zinit.git/zinit.zsh ]]; then
    print -P "%F{33} %F{220}Installing %F{33}ZDHARMA-CONTINUUM%F{220} Initiative Plugin Manager (%F{33}zdharma-continuum/zinit%F{220})â€¦%f"
    command mkdir -p "$HOME/.local/share/zinit" && command chmod g-rwX "$HOME/.local/share/zinit"
    command git clone https://github.com/zdharma-continuum/zinit "$HOME/.local/share/zinit/zinit.git" && \
        print -P "%F{33} %F{34}Installation successful.%f%b" || \
        print -P "%F{160} The clone has failed.%f%b"
fi

source "$HOME/.local/share/zinit/zinit.git/zinit.zsh"
autoload -Uz _zinit
(( ${+_comps} )) && _comps[zinit]=_zinit

# Load a few important annexes, without Turbo
# (this is currently required for annexes)
zinit light-mode for \
    zdharma-continuum/zinit-annex-as-monitor \
    zdharma-continuum/zinit-annex-bin-gem-node \
    zdharma-continuum/zinit-annex-patch-dl \
    zdharma-continuum/zinit-annex-rust

### End of Zinit's installer chunk
#+end_src

*** Plugins
#+begin_src zsh
# Load plugins with turbo mode for faster startup
# wait'0' defers loading until after prompt is shown
zinit wait lucid for \
    atinit"ZINIT[COMPINIT_OPTS]=-C; zicompinit; zicdreplay" \
        zdharma-continuum/fast-syntax-highlighting \
    blockf \
        zsh-users/zsh-completions \
    atload"!_zsh_autosuggest_start" \
        zsh-users/zsh-autosuggestions \
        MichaelAquilina/zsh-you-should-use # doesn't work with both aliases like g grep...
#+end_src

**** [[https://github.com/Aloxaf/fzf-tab/issues/461][fzf-tab]]
#+begin_src zsh
# Load fzf-tab with turbo mode
zinit wait lucid for \
    Aloxaf/fzf-tab

export _PREVIEW_="$ZDOTDIR/preview.zsh"
local extract="
local in=\${\${\"\$(<{f})\"%\$'\0'*}#*\$'\0'}
local -A ctxt
for entry in \${(@ps:\2:)CTXT}; do
    local key=\${entry%%=*}
    local value=\${entry#*=}
    ctxt[\$key]=\$value
done
local realpath=\${ctxt[IPREFIX]}\${ctxt[hpre]}\$in
realpath=\${(Qe)~realpath}
"
zstyle ':fzf-tab:complete:*:*' fzf-flags --preview=$extract';$_PREVIEW_ $realpath'
#+end_src

#+begin_src zsh :tangle ~/.config/zsh/preview.zsh :shebang "#!/usr/bin/env zsh"
# Check if the file exists
if [[ -e "$1" ]]; then
    # If the file is a regular text file, display its content
    if [[ $(file --mime-type -b "$1") == text/* ]]; then
        # Use highlight for syntax highlighting or fallback to cat
        (highlight -O ansi "$1" || cat "$1") 2> /dev/null | head -500
    else
        # If not a text file, display the file type
        file "$1"
    fi
else
    # If the file does not exist, print the filename
    echo "$1"
fi
#+end_src

*** Snippets
#+begin_src zsh
# zinit snippet OMZP::git
zinit snippet OMZP::sudo
# zinit snippet OMZP::tmuxinator
# zinit snippet OMZP::docker
zinit snippet OMZP::command-not-found
#+end_src

** Completion styling
#+begin_src zsh
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Za-z}'
zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"
zstyle ':completion:*' menu no
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'ls --color $realpath'
zstyle ':fzf-tab:complete:__zoxide_z:*' fzf-preview 'ls --color $realpath'
zstyle ':completion:*:*:docker:*' option-stacking yes
zstyle ':completion:*:*:docker-*:*' option-stacking yes
#+end_src

** [[https://www.reddit.com/r/zsh/comments/1iyajgx/i_added_bottom_padding_to_my_zsh_terminal_so/][Bottom padding]]
#+begin_src zsh
# Add padding only at initial prompt, not during editing
function _bottom_padding_precmd() {
  # Only add padding when not in history or other widgets
  if [[ -z $WIDGET ]]; then
    local padding=$((LINES/2))
    for ((i=0; i<padding; i++)); do echo; done
    echo -ne "\033[${padding}A"
  fi
}
# Add to precmd functions but make sure it runs only once
autoload -Uz add-zsh-hook
add-zsh-hook precmd _bottom_padding_precmd
#+end_src

** ZLE
*** TODO Tasks
- [ ] Test Alt+Ctrl+J for vi mode toggle
- [ ] Verify all Ctrl+X combinations work
- [ ] Add keybinding for common commands (analyze with atuin)
- [ ] Implement nohist function if needed


# Ctrl+X Ctrl+N - dynamic history completion
bindkey '^X^N' _history-complete-older
*** Options
#+begin_src zsh
# Completion options with cache
# Skip security check (-C) for faster startup, check manually with: compaudit
autoload -Uz compinit
if [[ -n ${ZDOTDIR}/.zcompdump(#qN.mh+24) ]]; then
    compinit
else
    compinit -C
fi

zstyle ':completion:*' matcher-list 'm:{a-z}={A-Za-z}'  # case-insensitive
setopt COMPLETE_IN_WORD
setopt AUTO_MENU
setopt LIST_AMBIGUOUS

# Colored completion
zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"
zstyle ':completion:*' menu select

# Use Bash-style word boundaries for all word operations
autoload -Uz select-word-style
select-word-style bash
#+end_src

*** Keybindings
**** Base Mode
#+begin_src zsh
# Default to emacs mode
bindkey -e
#+end_src

**** Tab Completion
#+begin_src zsh
# Tab - menu completion
bindkey '^I' expand-or-complete-prefix
#+end_src

**** Line Editing
#+begin_src zsh
# Ctrl+U - kill from cursor to beginning of line (like Bash)
bindkey '^U' backward-kill-line

# Ctrl+1 maps to Alt+1
bindkey -s '^1' '\e1'

# C-M-] - search prev char (vi)
bindkey '^[^]' vi-find-prev-char
# C-] - search next char (vi)
bindkey '^]' vi-find-next-char

# TODO: fix M-y
backward-kill-blank-word() {
  # Save current position and buffer state
  local old_lbuffer="$LBUFFER"
  
  # Remove trailing spaces, then kill the last word
  LBUFFER="${LBUFFER%${LBUFFER##*[![:space:]]}}"
  [[ $LBUFFER =~ '^(.*[[:space:]])[^[:space:]]+$' ]] && LBUFFER="${match[1]}" || LBUFFER=
  
  # Add killed text to cutbuffer for yanking
  local killed="${old_lbuffer#$LBUFFER}"
  if [[ -n "$killed" ]]; then
    CUTBUFFER="$killed"
  fi
}
zle -N backward-kill-blank-word
bindkey -M emacs '^W' backward-kill-blank-word
#+end_src

**** Meta Commands
#+begin_src zsh
# Ctrl+X Ctrl+E - edit command line in editor (like bash)
autoload -Uz edit-command-line
zle -N edit-command-line
bindkey '^X^E' edit-command-line

# Ctrl+X Ctrl+X - reload shell
bindkey -s '^X^X' ' [[ $(jobs) ]] || exec ${SHELL:-/bin/zsh}\n'

# Ctrl+X \ - nohist (if you have this function)
# bindkey -s '^X\\' ' nohist\n'
#+end_src

**** Wrapping
#+begin_src zsh
# Ctrl+X $ - wrap in $()
bindkey -s '^X$' ' $()\e[D'

# Ctrl+X < - wrap in <()
bindkey -s '^X<' ' <()\e[D'

# Ctrl+X " - wrap in double quotes
bindkey -s '^X"' ' ""\e[D'

# Ctrl+X ' - wrap in single quotes
bindkey -s "^X'" " ''\e[D"
#+end_src

**** Redirections
#+begin_src zsh
bindkey -s '^X0' ' &>/dev/null '
bindkey -s '^X1' ' >/dev/null '
bindkey -s '^X2' ' 2>/dev/null '
bindkey -s '^X3' ' 2>&1 '
#+end_src

**** Emacs-Inspired Navigation
#+begin_src zsh
# Ctrl+X Ctrl+F - find file with fzf
bindkey -s '^X^F' ' "$(fd -tf . 2>/dev/null | fzf)"\n'

# Ctrl+X d - find directory with fzf
bindkey -s '^Xd' ' "$(fd -td . 2>/dev/null | fzf)"\n'

# Ctrl+X Ctrl+J - open dired in emacs
# bindkey -s '^X^J' ' emacsclient -a "" -t --eval '\''(dired ".")'\'''\n'

# Alt+X - command search with preview
# bindkey -s '\ex' 'print -l ${(k)commands} | sort -u | grep -v ^_ | fzf --preview='\''man {} 2>/dev/null||echo "No preview available"'\'')'

zle -N copy-line-to-clipboard; copy-line-to-clipboard() { print -n -- "\e]52;c;$(print -n -- "$BUFFER" | base64)\a" }
bindkey '\ew' copy-line-to-clipboard

zle -N copy-pwd-to-clipboard; copy-pwd-to-clipboard() { print -n -- "\e]52;c;$(print -n -- "${PWD/#$HOME/\~}" | base64)\a" }
bindkey '^Xp' copy-pwd-to-clipboard

zle -N exec-bash; exec-bash() { BUFFER='exec bash'; zle accept-line }
bindkey '^X^' exec-bash

bindkey -s '\e[24~' '^X'

#+end_src

**** Vi/Emacs Mode Toggle
#+begin_src zsh
# Alt+Ctrl+J - toggle between vi and emacs mode
_toggle_vi_emacs() {
  if [[ $KEYMAP == vicmd ]] || [[ $KEYMAP == viins ]]; then
    bindkey -e
    echo "Switched to emacs mode"
  else
    bindkey -v
    echo "Switched to vi mode"
  fi
  zle reset-prompt
}
zle -N _toggle_vi_emacs
bindkey '^[^J' _toggle_vi_emacs
#+end_src

*** Special Keys
#+begin_src zsh
# Ctrl+M - accept line (fix for ghostty with kitty keyboard protocol)
bindkey '^[[109;5u' accept-line
#+end_src

** Aliases
#+begin_src zsh :noweb yes
<<sh|.org:aliases()>>

# Enable tab completion for function wrappers
<<sh|.org:completion-functions()>>
for entry in "${_completion_funcs[@]}"; do
    IFS=: read -r alias_name cmd_name <<< "$entry"
    compdef "$alias_name=$cmd_name"
done
unset _completion_funcs
#+end_src

*** Global aliases
There's also =https://github.com/momo-lab/zsh-abbrev-alias=

#+begin_src zsh
alias -g ...='../..'
alias -g ....='../../..'

alias -g F="| fzf"
alias -g H="| head"
alias -g T="| tail"
alias -g G="| grep"
alias -g S="| sort"
alias -g U="| sort -u"
alias -g Q="| qrencode -t ansiutf8"
alias -g W="| wc -l"
alias -g X="| xargs"
alias -g Y="| yank"

alias -g TS='| ts "%F %H:%M:%.S"'
#+end_src

*** Suffix aliases
#+begin_src zsh
alias -s {png,jpg}='feh'
alias -s {ape,avi,flv,m4a,mkv,mov,mp3,mp4,mpeg,mpg,ogg,ogm,wav,webm}=mpv
#+end_src

** Functions
#+begin_src zsh :noweb yes
<<sh|.org:functions()>>
#+end_src

** External commands
#+begin_src zsh :noweb yes
<<sh|.org:commands(shell="zsh")>>
#+end_src

** [[https://superuser.com/questions/1563825/is-there-a-zsh-equivalent-to-the-bash-help-builtin][zsh equivalent to bash's `help` builtin]]
#+begin_src zsh
unalias run-help
autoload run-help
HELPDIR=/usr/share/zsh/"${ZSH_VERSION}"/help
alias help=run-help
#+end_src

* zprofile
#+begin_src zsh :tangle ~/.config/zsh/.zprofile
[ -f ~/.profile ] && . ~/.profile
#+end_src

* [[https://www.reddit.com/r/zsh/comments/3ubrdr/comment/cxe7ejm/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button][zshenv]]
#+begin_src zsh :tangle ~/.zshenv
# export ZSH_CACHE_DIR="$XDG_CACHE_HOME/zsh"
ZDOTDIR=$HOME/.config/zsh
YSU_MESSAGE_FORMAT="$(tput setaf 1)Hey! I found this %alias_type for %command: %alias$(tput sgr0)"
YSU_MESSAGE_POSITION="after"
# . $ZDOTDIR/.zshenv
#+end_src
