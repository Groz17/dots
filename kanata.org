#+property: header-args :tangle ~/.config/kanata/config.kbd :comments org
#+startup: content
;; two/multiple keys to activate layer?
;; config.kbd beautifier?

;; use touchpad for \ (in the middle)?
;; would be cool to try using space/touchpad to mean <c-o> (for vim insert mode)
;;write diff between pc and laptop?
;; check if tangled code is valid kanata when saving?


autoshift
  I use a variable timing depending on the finger. From 100 ms on the index to 135 ms on the pinky. Note that I use low profile choc switches. 
  activate autoshift only when key is released, so u can use whichkey neovim w/ 13 leader?

* TODO TASK LIST
org-babel for kanata/config files in general?

basically i want: 
- [ ] block keyboard input
- [ ] use touchpad for localleader?

- [ ] if u manage to make shift+1,2,3,4 useless, make sure to bind that to f keys for emacs (macros)
- [ ] key that repeats two times the shifted version of char, for stuff like &&, etc...
- [ ] hold keys for stuff like \ and C-z for emacs (from insert mode normal command?)
- [ ] rpt-key should take 1-8 as argument for last 1-8 keys? also range
- [ ] maybe also prefix for lsp, etc...?
- [ ] also touchpad for C-u?
- [ ] use super + q for macros (bind to f23 and wtype in hyprland?)
- [ ] disaccoppia ctrl+<symbol> to ctrl+<symbol> when held, like ctrl-h in emacs (works for prefix keymaps)
- [ ] create function layer?
- [ ] usa mdSlash/hyprkan
- [ ] disable for stuff like games? emacs tetris i need repeat
- [ ] caps/a & l/; for [,]
- [ ] create layer for left hand with hjkl being respectively gfds
- [ ] 2/3 & 9/0 easy to reach
- [ ] make a touchpad press be rpt-any? also explore zones... (maybe also for symbols, like %(left top)&^(right top), rpt-any (top center))

- [ ] layer to select layers? which-key?
- [ ] writing layer? like for quotes, em dash...
- [ ] mappings to transform last \S+ to pascal, camel (corce-like, same letters)
- [ ] bottom alt tap/hold mapping?
- [ ] one-shot shift? chord?
- [ ] how to make tap-dance work with modifiers?
- [ ] rpt-any should be in either side of the keyboard (maybe altgr/alt?)
- [ ] how to use with multi like ^ww?
- [ ] mappa in modo da rendere piu facili combinazioni usate tipo ctrl-- and ctrl-+ per zoomare?
- [ ] also sdc are easier to type together
- [ ] mappa ctrl-o per normal mode comments in neovim?
- [ ] make ctrl-letter generalized: when not release act as ctrl (do these for All letters and maybe overwrite for HRM?)
- [ ] press symbol that toggle the functionality of a key? like for mouse/square brackets
- [ ] crea prefix for popup completion?
- [ ] use altgr hold for accents/fancy symbols like em dash?
- [ ] maybe use prefix for operators? like g or d hold?
- [ ] mouse layer: trackpoint held and j left k right m middle

crea tutti o i piu importanti prefix in emacs like (place keys considering importance and mnemonics, like /&? for M-s)
- [X] C-h
- [X] C-x
- [ ] C-c (also stuff like C-c C-x)
- [X] M-s
- [ ] M-g
  also for every two keypress prefix use a letter, like q (macro key in vim) for C-x C-k (macro key in emacs), etc...

* SETTINGS
#+begin_src kbd

(defcfg
danger-enable-cmd yes
;;obiettivo finale
  ;; Block keys outside the ideal keyboard size/limit, build muscle memory
  ;; block-unmapped-keys yes
  process-unmapped-keys yes
  ;;linux-x11-repeat-delay-rate 300,73
  log-layer-changes yes
  linux-use-trackpoint-property yes
;; linux-only-linux-dev-names-onClude
  linux-continue-if-no-devs-found yes
  ;; notify-cfg-reload-silent yes
  linux-dev-names-exclude (
    "Keebart sofle_choc_pro"
    ;; "ThinkPad Extra Buttons"
    ;; "TPPS/2 IBM TrackPoint"
  )
  concurrent-tap-hold yes
;;  chords-v2-min-idle 200
)

#+end_src

* KEYBOARD

@ISO extra key from ANSI

#+begin_src kbd
;; e un bene che bspc sia in una posizione scomodina (non vuoi favoreggiare sbagli)
(defsrc
  esc 
  grv  1    2    3   4    5    6    7 8 9 0 - = bspc
  tab  q    w    e   r    t    y    u i o p [ ]   
  caps a    s    d   f    g    h    j k l ; ' \    ret
  lsft <    z    x   c    v    b    n m , . / rsft
  lctl lmet lalt spc ralt menu prnt rctl
  mlft mmid mrgt
)
  ;;lalt           spc            ralt menu
;; maybe lftl ctrl and mrgt shift and mmid alt? layers ofc

(deflayer base
  @esc 
  @grv  @d1   @d2   @d3  @d4   @d5   @d6   @d7 @d8 @d9 @d0 @- @= @bspc
  @tab  @q    @w    @e   @r    @t    @y    @u  @i  @o  @p @[ @]   
  @caps @a    @s    @d   @f    @g    @h    @j  @k  @l  @; @' @\    @ret
  @lsft @ISO  @z    @x   @c    @v    @b    @n  @m  @,  @. @/ @rsft
  @lctl @lmet @lalt @spc @ralt @menu @prnt @rctl
  @mlft @mmid @mrgt
)
#+end_src

* VARIABLES
#+begin_src kbd
(defvar
  tt 300
  ht 330
)

 ;;(defvirtualkeys fk1  (layer-switch nav))
#+end_src

* ALIAS

z=f13, x=f14, c=f15, ...
you could inoremap/abbrev them tbh

#+begin_src kbd

(defalias

;; []-> -+/_*
  [   (tap-hold 200 249 [ [) ;; same place as [{
  ]   (tap-hold 200 249 ] (macro S-8))
  \   (tap-hold 175 175 \ (macro S-\))
  ;; f11 lrld
  ;;f11 (layer-switch nav)

  ;; alla fine tab naviga nei form...
 ;; tab (tap-hold 175 100 tab (tap-hold-release-timeout 0 200 tab (layer-while-held nav) (macro S-tab)))
 tab (tap-hold 175 100 tab (tap-hold-release-timeout 0 200 tab (layer-while-held nav) (macro S-tab)))
  home   home
  ;;[   (tap-hold 200 249 [ (layer-switch nav))
  ;; non funge
  ;;[   (tap-hold 200 249 (layer-switch nav) (layer-switch base))
  ;;]   (tap-hold 200 249 ] (layer-switch base))
  ;; in futuro [ (layer-switch nav)
  ;; how to tap caps to go to layer starting only if in another layer?
  ;;tab (on-press toggle-virtualkey fk1)
  ;; menu (layer-switch nav)
  ;; opposite of | for shell scripting
  ;; equal has horizontal lines like menu
  menu (tap-hold 175 175 = (tap-hold-press-timeout 0 100 = \ (macro S-=)))
  prnt (tap-hold 175 175 = (tap-hold-press-timeout 0 100 = \ (macro S-=)))
  ret (tap-hold 200 249 ret (macro S-ret))
  ;; can rpt-any work with chords as well? if not make it work
  ;; combine rpt-any w/ tap-hold? like for neovim debug
  ;; make rpt-any work w/ chords?
  ;;vin   (tap-hold 200 249 rpt-any (layer-while-held nav))
  ;; vin   (tap-hold 200 249 rpt-any (layer-while-held nav))
  ;; vin (tap-dance 300 (tap-hold-press-timeout 200 200 rpt-any [ (macro S-[)) [ )
;; make rpt-any work w/ esc/cr (fd/jk)
  ;; caps (tap-dance 300 (rpt-any (caps-word 10000) ))
  ;; caps (tap-hold 175 200 (tap-dance 300 (rpt-any (caps-word 10000) )) (tap-hold-press-timeout 0 100 [ lctl (macro S-[)))
  ;; also continue if pressing c-h, c-w, etc...
  ;; caps-word with number before (like v:count) to mean make these next n letters uppercase
  ;;caps (tap-hold 175 200  rpt-any (tap-hold-press-timeout 0 100 rpt-any (layer-while-held nav) (caps-word 10000)))
  ;;caps (tap-hold 175 200  rpt-any (tap-hold-press-timeout 0 100 rpt-any (layer-while-held nav) (caps-word 10000)))
  ;; basically at the opposite end of '/"
  ;;caps (tap-hold 175 175  grave (tap-hold-press-timeout 0 100 grave lsft (macro S-grave)))
  ;;caps (tap-hold 175 175  grave (tap-hold-press-timeout 0 100 grave (layer-while-held num) (macro S-grave)))
  ;;basically\ because evil, universal argument
  ;; maybe this way u can use c-u in insert mode (replicate readline in emacs)
  ;;caps (tap-hold 175 175  grave (tap-hold-press-timeout 0 100 grave (macro \ C-u) (macro S-grave)))
  caps (tap-hold 175 175  grave (tap-hold-press-timeout 0 100 grave (layer-while-held nav) (macro S-grave)))
  ;;< (tap-hold-press-timeout 200 175 S-\ lsft (macro S-[))
;;  < (macro S-6) ;; ^ looks like shift symbol
;; useful for (emacs lisp)
  ;;vin   (tap-hold 200 249 bspc (layer-while-held nav))

  rsft (tap-hold-press-timeout 200 175 S-0 rsft (macro S-]))
  ;; capsline?
  cwr (caps-word-toggle 10000)
  ;; lalt (tap-hold 200 200 mmid lalt)
  ;; lalt mlft
  ;;lalt (tap-hold-press-timeout 200 200 mlft lalt bspc)
  ;; lalt (tap-hold-press-timeout 200 200 - lalt mlft)
  ;; comfortable (u also use left thumb for space)
  ;; do em dash/ dash / en? others? also underscore?
  ;;lalt (tap-hold 200 200 - (unicode ‚Äî))
  ;;lalt ((tap-hold-press-timeout 200 175 - (layer-while-held symbols) (unicode ‚Äî)))
  ;;combina bene con caps-word...
  ;; lalt (tap-hold 200 175 - (macro S--))
  ;; to easily press -> or smth...
  ;; maybe _ when holding so same speed as for -?
  ;;lalt (tap-hold-press-timeout 200 175 - (multi - lsft) (macro S--))
  ;;lalt (tap-hold-press-timeout 200 175 - (macro S-\)  (macro S--))
  ;; doesn't work with \| tough
  ;; i guess also useful for evil in emacs, like for calc
  ;; lalt (tap-hold 175 175 - (tap-hold-press-timeout 0 100 - (multi \) (macro S--)))
  ;; lalt (tap-hold 175 175 - (tap-hold-press-timeout 0 230 - (layer-while-held audio) (macro S--)))
  ;; combacia anche con terminal dove alt=esc
  ;; also add tap dance for double esc = pseudo key
  lalt (tap-hold-press-timeout 175 175 esc esc (macro S-esc))

  ;; combina bene con - per pipelines
  ;;ralt (macro S-\)

  ;; basically better position for - and = (this make them work with shift layer)
  ;;ralt (tap-hold 200 175 = (macro S-=))
  ;; per shell pipeline: mnemonic: eventuali opzioni vengono prima della pipe
  ;; also nice for org mode tables |-tab goes all in one direction
  ;;ralt (tap-hold 175 150 (multi lsft \) (tap-hold-press-timeout 0 100 (multi lsft \) \ (macro S-d)))
  ;;ralt (tap-hold 175 175 = (tap-hold-press-timeout 0 100 = \ (macro S-=)))
  ;; - and = similar to j and k to zoom in pdfs, etc...
  ralt (tap-hold 175 175 - (tap-hold-press-timeout 0 100 - \ (macro S--)))
  ;; ralt esc

  ;;lctl (macro S-3)
   lctl rpt-any ;; ... doesn't work with c-m-s-v though? for emacs
  ;;lctl (macro S-1) ;; near | and vertical aligned with 1/!
  rctl (macro S-8)
  ;; facile usare |-tab in orgmode (also nice for pipelines near -)
  ;; so i can easily do |- in org mode for tables ; also near - for bash commands
  lmet (macro S-\)

  ;; Keyboard blocking toggle - useful when passing PC to others
  blocked-toggle (layer-toggle blocked)

#+end_src

#+name: ISO
#+begin_src bash :noweb yes :tangle no
[[ <<chassis()>> = "desktop" ]] && echo '9' || echo '6'
#+end_src

#+begin_src conf :noweb yes
lsft (tap-hold-press-timeout 200 175 (macro S-<<ISO()>>) lsft (macro S-[))
#+end_src


** MOUSE
#+begin_src kbd :tangle (if (string-match  "Power N/A, battery unknown (N/A% load, remaining time N/A)"(battery)) "no" (cdr (assq :tangle (org-babel-parse-header-arguments (cdr (assoc "header-args" org-keyword-properties))))))
;; how to make touchpad work?

;; maybe define these just for neovim since u aint gonna use the mouse (define env var in neovim like IS_NEO?)
;; also use trackpoint tap for left click and hold for right click
;; mi forza a non usare il mouse
;; why doesn't the touchpad work?
;; TODO: add held action for these (like push to talk and ???)
;;mlft (tap-hold 175 100 [ (tap-hold-release-timeout 0 200 [ (layer-while-held symbols) (layer-while-held symbols)))
;; mlft (tap-hold 175 100 [ (tap-hold-release-timeout 0 100 [ (layer-while-held num) mlft))
mlft (tap-hold 175 100 [ (tap-hold-release-timeout 0 100 [ [ mlft))
;;tap:- hold:_ double-tap:= (it all makes sense)
;; mlft (tap-dance 230 ( (tap-hold-press-timeout 200 175 - - S-- ) =))
 ;; mlft (tap-hold 175 100 bspc (tap-hold-release-timeout 0 200 [ (layer-while-held symbols) mlft))
;; mlft mlft
;;mlft (tap-hold 175 150 - (tap-hold-release-timeout 0 100 - [ -))
;; rpt-any kinda allows to cheat key-repeat... (press one and the other in rapid succession) (the key or the other rpt-any key)
;; maybe make it so key-repeat works?
;;mlft (tap-hold 175 150 rpt-any (tap-hold-release-timeout 0 100 rpt-any (layer-while-held symbols) -))

;; use \ as mmid (like ascii sequence, also nice for localleader?)
;; maybe keep as mmid? and trackpoint as mlft&mrgt
;;mmid (tap-hold 175 100 \ (tap-hold-release-timeout 0 100 \ (layer-while-held num) (macro S-\)))
;;mmid (tap-hold 175 100 S-- (tap-hold-release-timeout 0 100 S-- (layer-while-held num) (macro S-\)))
;;mmid S--
mmid mmid

;; non usare mrgt come symbols layer xke i simboli sono gia alla destra in qwerty
 ;;mrgt (tap-hold 175 100 ] (tap-hold-release-timeout 0 200 ] (layer-while-held num) (layer-while-held num)))
 mrgt (tap-hold 175 100 ] (tap-hold-release-timeout 0 200 ] ] mrgt))
;; basically right thumb backspace ] as layer held s-bspc, left thumb [ and held ] and [ as layer
;; mrgt (tap-hold 175 100 bspc (tap-hold-release-timeout 0 200 bspc ] mrgt))
;;mrgt (tap-hold 175 100 ] (tap-hold-release-timeout 0 100 ] (layer-while-held num) (macro S--)))
;;mrgt (tap-hold 175 150 (macro S--) (tap-hold-release-timeout 0 100 (macro S--) ] (macro S--)))
;;mrgt (tap-hold 175 150 rpt-any (tap-hold-release-timeout 0 100 rpt-any (layer-while-held symbols) (macro S--)))

;; hai a disposizione 4 caratteri: lsft and 3 mouse buttons.
;; does tap-dance work with rpt-any? no, sfrutta a tuo vantaggio...
;; use leader and localleader with mouse buttons to get more symbols; also use chords with them? like modifier+leader, since a leader assumes
;; something after this is great...
;; mrgt (tap-dance 300 ( (macro S--) = ))

#+end_src

#+begin_src kbd :tangle (if (string-match  "Power N/A, battery unknown (N/A% load, remaining time N/A)"(battery)) (cdr (assq :tangle (org-babel-parse-header-arguments (cdr (assoc "header-args" org-keyword-properties))))) "no")
mmid mmid
mrgt mrgt
mlft mlft
#+end_src

** Macros
add sleep w/ key -> cmd sleep 2?
;; rmet-q(dynamic-macro-record 0)
;; rmet-@(dynamic-macro-play   0)

EXWM would be perfect for these ig
v:count?
also S-9 and S-0 could be an idea (like emacs c-x())
better to toggle though
sleep-for?
super+q?
useful for repetitive password insertions üòÅ (ssh)
show macro content

#+begin_src kbd
;; - (tap-hold-press-timeout 175 175 rpt-any - (macro S--))
;; in tridactyl: bind f12( -?
- (tap-hold-press-timeout 175 175 (dynamic-macro-record 0) - (macro S--))
= (tap-hold-press-timeout 175 175 dynamic-macro-record-stop = (macro S-=))
;;grv (tap-hold 200 249 grv (macro S-grv)) ;; usa C-u 0 for emacs (comes before vim)
;; remember u can also use keys like FAVORITES (from mapping.txt)
;; grv (tap-hold 200 249 f14 (macro S-grv)) ;; usa C-u 0 for emacs (comes before vim)
grv (tap-hold 200 249 (dynamic-macro-play 0) (macro S-grv)) ;; usa C-u 0 for emacs

;; double shift/caps tab?
;; map it to disable/toggle kanata (for when you pass pc to other)
;; esc (tap-hold 200 249 (dynamic-macro-play 0) (macro S-grv)) ;; usa C-u 0 for emacs
;; how to repeat?
;; esc (tap-hold 200 249 (dynamic-macro-play 0) (dynamic-macro-play 0)) ;; usa C-u 0 for emacs
esc (dynamic-macro-play 0)
#+end_src

** HRM
Keys used: d, f (& mirrored) and space (no need for shift because of autoshift)
Order tap-hold section based on keyboard location (space, zxcv, asdfg, qwert)
Keep in mind there's also shift, caps, tab, ISO key, etc...
There's also modifier+function keys btw

*** Super
#+begin_src kbd
spc (tap-hold-press-timeout 0 200 spc lmet (multi S-spc))
#+end_src

*** Ctrl
#+begin_src kbd
;; make lctl sticky (for ctrl-h backspace), like ctrl-h and then press again should repeat?
;; if d and m pressed at the same time-> double ctrl, for things like c-cr (c-c-m)
d (tap-hold 175 175 d (tap-hold-press-timeout 0 230 d lctl (macro S-d)))
k (tap-hold 175 175 k (tap-hold-press-timeout 0 230 k rctl (macro S-k)))
#+end_src

*** Alt
#+begin_src kbd
;; change this out for the list:https://github.com/jtroo/kanata/blob/main/cfg_samples/home-row-mod-advanced.kbd
f (tap-hold 175 175 f (tap-hold-press-timeout 0 230 f lalt (macro S-f)))
;; usa release e press solo x escape...
j (tap-hold 175 175 j (tap-hold-press-timeout 0 230 j lalt (macro S-j)))

#+end_src

** Toggle
#+begin_src kbd
;; z inspiration from c-z toggle evil in emacs...
;; make this sticky
;; basically Toggle cause C-z toggle evil mode in emacs
z (tap-hold 150 175 z (tap-hold-press-timeout 0 75 z f13 (macro S-z)))
. (tap-hold 150 175 . (tap-hold-press-timeout 0 75 . f13 (macro S-.)))
#+end_src

** TODO
#+begin_src kbd
v (tap-hold-press-timeout 175 175 v v (macro S-v))
n (tap-hold-press-timeout 175 175 n n (macro S-n))
#+end_src

** Terminal
#+begin_src kbd
;; use e/i 'cause middle finger is the strongest ig
;; crea modifiers nuovi with super + combinazione di altri modifiers: super+{cltrl,alt,shift} 2^3 insieme delle parti (except shift only for hyprland)
;; can also do super+modifiers+symbols (for neovim/emacs/editor leader...)
;; e (tap-hold 175 150 e (tap-hold-press-timeout 0 100 e (multi lmet lalt) (macro S-e)))
;;lmet lctl so i can press lmet+lctl+lalt easily w/ w+d
e (tap-hold 175 175 e (tap-hold-press-timeout 0 100 e (multi lmet lalt) (macro S-e)))

i (tap-hold 175 175 i (tap-hold-press-timeout 0 150 i (multi lmet lalt) (macro S-i)))
#+end_src

** One-shot/localleader (C-c ...)
#+begin_src kbd
;; u could maybe use this for hyper/super in emacs since u run it as a GUI
;;c (tap-hold 175 200 c (tap-hold-press-timeout 0 200 c (multi lmet lalt) (macro S-c)))
;; nice position so u can use ctrl-x arrow in emacs

;; for C-u use macros , v:count like for C-u,C-u,C-u

;;c (tap-hold 175 200 c (tap-hold-press-timeout 0 200 c f15 (macro S-c)))
;; m (tap-hold 175 200 m (tap-hold-press-timeout 0 200 m f15 (macro S-m)))
m (tap-hold 175 175 m (tap-hold-press-timeout 0 230 m (layer-while-held c-c-prefix) (macro S-m)))
;; When held with d (ctrl), c should act as a layer that prefixes all keys with C-c
c (tap-hold 175 175 c (tap-hold-press-timeout 0 230 c (layer-while-held c-c-prefix) (macro S-c)))
#+end_src

** Window mappings

#+begin_src kbd
;; magari crea f16 when it does this char= getchar; exe <cmd>char..<cr> (basically one letter commands) and maybe double quotes two letters?
;; so i can preserve C-\ input in emacs
;; a held activates a layer where s triggers C-c C-x
;; ; held activates a layer where l triggers C-c C-x
a (tap-hold 175 175 a (tap-hold-press-timeout 0 175 a (layer-while-held a-layer) (macro S-a)))
; (tap-hold 0 150 ; (tap-hold-press-timeout 0 100 ; (layer-while-held semicolon-layer) (macro S-;)))
#+end_src

#+begin_src kbd
;; one-shot modifier for ctrl-u universal arg?
;;per vim
r (tap-hold 175 175 r (tap-hold-press-timeout 0 100 r f19 (macro S-r)))
;; work on autorepeat? like if over>250 UU?
;; for emacs (4 is the default)
;;maybe C-u for emacs? when held?
u (tap-hold 175 175 u (tap-hold-press-timeout 0 150 u f19 (macro S-u)))
#+end_src

** C-x emacs
C-x is also useful for readline

#+begin_src kbd
;;s (tap-hold-release 150 175 s (tap-hold-press-timeout 0 75 s (macro C-x) (macro S-s)))
;; how to activate C-x when pressed and not released?
;;s (tap-hold 150 175 s (tap-hold-press-timeout 0 230 s (macro C-x) (macro S-s)))
;; make it press f12 unless released so which-key buffer pops up...
;; make it hyper so u can hold s, sd, etc...
;; s and l now just tap normally so ctrl-layer can intercept them
s (tap-hold-press-timeout 150 175 s f12 (macro S-s))

l (tap-hold-press-timeout 150 175 l f12 (macro S-l))
#+end_src

#+begin_src elisp
;; basically x is for snacks keymaps (ks mnemonic)
x (tap-hold 150 175 x (tap-hold-press-timeout 0 124 x x (macro S-x)))
, (tap-hold-press-timeout 190 157 , , (macro S-,))
#+end_src

** Help
#+begin_src kbd
;; for emacs

;; fai che quando g e premuto, h diventa ctrl e viceversa (for emacs help mappings)
g (tap-hold 150 200 g (tap-hold-press-timeout 0 150 g f18 (macro S-g)))
h (tap-hold 150 200 h (tap-hold-press-timeout 0 150 h f18 (macro S-h)))
#+end_src

** Picker (window mnemonic)
Those should be temporary mappings until editor's default mappings are added

#+begin_src kbd
;; use modifier instead so u can use ^w{h,j,k,l} in terminal & in insert mode
w (tap-hold 175 200 w (tap-hold-press-timeout 0 100 w f17 (macro S-w)))
o (tap-hold 175 200 o (tap-hold-press-timeout 0 100 o f17 (macro S-o)))
#+end_src

** Translation
#+begin_src kbd
t (tap-hold 150 200 t (tap-hold-press-timeout 0 150 t f14 (macro S-t)))
y (tap-hold 150 200 y (tap-hold-press-timeout 0 150 y f14 (macro S-y)))
#+end_src

#+begin_src kbd
p (tap-hold-press-timeout 175 175 p p (macro S-p))
q (tap-hold-press-timeout 175 175 q q (macro S-q))

b (tap-hold-press-timeout 175 175 b b (macro S-b))
#+end_src

#+begin_src kbd

' (tap-hold-press-timeout 200 157 ' ' (macro S-'))
` (tap-hold-press-timeout 200 157 ` ` (macro S-`))

;; for searching... mnemonic: / in Vim
ISO (tap-hold-press-timeout 200 175 S-9 (macro A-s) (macro S-[))

;; / simmetrico di (
;;/ (tap-hold-press-timeout 200 157 / ] (macro S-/))
;; tanto usi rpt-any, giusto? 
;; maybe C-s when held for emacs?
;;/ (tap-hold-press-timeout 200 157 / rsft (macro S-/))
;;/ (tap-hold-press-timeout 200 157 / (multi lalt s) (macro S-/))
/ (tap-hold-press-timeout 200 157 / (macro A-s) (macro S-/))

bspc (tap-hold-press-timeout 175 175 bspc bspc (macro S-bspc))

;; tasti liberiii (maybe use (held) super for hyprland/wm, like associate with workspace name)
;; do maybe maths
;; maybe function keys when held? but what about shifted fun keys?
d1 (tap-hold-press-timeout 175 175 1 1 (macro S-1))
;; d2 (tap-hold-press-timeout 175 175 2 2 (macro S-2))
d2 (tap-hold 175 175 2 (tap-hold-press-timeout 0 230 2 (layer-while-held audio) (macro S-2)))
d3 (tap-hold 175 175 3 (tap-hold-press-timeout 0 230 3 (layer-while-held mouse) (macro S-3)))
d4 (tap-hold-press-timeout 175 175 4 4 (macro S-4))
d5 (tap-hold-press-timeout 175 175 5 5 (macro S-5))
d6 (tap-hold-press-timeout 175 175 6 6 (macro S-6))
d7 (tap-hold-press-timeout 175 175 7 7 (macro S-7))
d8 (tap-hold-press-timeout 175 175 8 8 (macro S-8))
;; change hold for 9 and 0 (i use shift for those)
;; d9 (tap-hold-press-timeout 175 175 9 9 (unicode ‚Äú))
;; d0 (tap-hold 175 175 0 (tap-hold-press-timeout 0 230 0 (layer-while-held audio) (unicode ‚Äù)))
d9 (tap-hold-press-timeout 175 175 9 9 (macro S-9))
d0 (tap-hold 175 175 0 (tap-hold-press-timeout 0 230 0 (layer-while-held audio) (macro S-0)))
)
#+end_src

* Fake Keys

#+begin_src kbd
;; (defvirtualkeys
;;   play-macro (dynamic-macro-play 0)
;;   stop-macro dynamic-macro-record-stop
;; )
#+end_src

* LAYERS
Combinazioni che non hanno senso quando tenute, e.g. as che darebbe luogo a F16 C-x, possono essere sostitutite con altre utili come C-c C-x.
how to use autoshift w/ a layer? like G to go to end
implement vim layer? like gg and stuff
notify when layer switching?
magari usalo anche x emacs (fallo simmetrico)
also use shift-arrow for orgs emacs

** Mouse
Could be useful for macros.

Also you could zoom to adjust travel distances.

#+begin_src kbd
(defalias
;; Basic mouse movements (interval=5ms, distance=1px)
msu (movemouse-up 5 1)
msd (movemouse-down 5 1)
msl (movemouse-left 5 1)
msr (movemouse-right 5 1)

;; Accelerated mouse movements (interval=5ms, accel-time=2000ms, min=1px, max=10px)
mau (movemouse-accel-up 5 2000 1 10)
mad (movemouse-accel-down 5 2000 1 10)
mal (movemouse-accel-left 5 2000 1 10)
mar (movemouse-accel-right 5 2000 1 10)

;; Mouse wheel scrolling (interval=50ms, distance=120)
mwu (mwheel-up 50 120)
mwd (mwheel-down 50 120)
mwl (mwheel-left 50 120)
mwr (mwheel-right 50 120)
)

(deflayer mouse
_
_ _ _ _     _ _ _ _    _    _  _    _ _ _
_ _ _ _     _ _ _ _    _    _  @mwu _
_ _ _ _     mlft _ _ @mal @mad @mau @mar _ _ _ _
_ _ _ _     _ _ _ _ mlft mmid mrgt @mwd _
_ _ _ _     _ _ _ _
_ _ _
)
#+end_src

** Navigation
Also toggle layer activation?

#+begin_src kbd
(deflayer nav
_
_ _ _ _     _ _ _ _    _    _  _    _ _ _
_ _ _ _     _ _ _ _    _    _  _    _
_ _ _ _     _ _ _ left down up rght _ _ _ _
_ _ _ _     _ _ _ _    ret  _  _    _ _
_ _ _ _     _ _ _ _
_ _ _
)
#+end_src

** Audio
#+begin_src bash :tangle ~/.config/hypr/scripts/fx :noweb yes :shebang "#!/usr/bin/env bash"
echo '{ "command": ["get_property", "af"] }' | socat - /tmp/mpvsocket | jq -er '.data[]?' ||\
    { echo '{ "command": ["set_property", "af","lowpass=f=400"] }' | socat - /tmp/mpvsocket ; false ;}  &&\
    echo '{ "command": ["set_property", "af",""] }' | socat - /tmp/mpvsocket 
#+end_src

#+begin_src bash :tangle ~/.config/hypr/scripts/recognize_song :noweb yes :shebang "#!/usr/bin/env bash"
dunstify "Recognizing song..."

cmd=(songrec)
args=(recognize --json)

if [[ <<chassis()>> == "desktop" ]]; then
  cmd=(flatpak run com.github.marinm.songrec)
  args+=(-d "Webcam C270 Mono")
fi

# Run the recognition command
song_json="$(timeout 13 "${cmd[@]}" "${args[@]}" 2>/dev/null)"
if [[ -n "$song_json" && "$song_json" != "null" ]]; then
    artist="$(jq -r '.track.urlparams | .["{trackartist}"]' <<<"$song_json" | php -r 'echo urldecode(file_get_contents("php://stdin"));')"
    title="$(jq -r '.track.urlparams | .["{tracktitle}"]' <<<"$song_json" |  php -r 'echo urldecode(file_get_contents("php://stdin"));')"
  dunstify "Title: $title" "Artist: $artist"
  printf "%s - %s\n" "$artist" "$title" | wl-copy
else
  dunstify "Song not found"
fi
#+end_src

#+begin_src kbd
(defalias
;; MediaMute: i (i looks like a mic)
microphone (cmd pactl set-source-mute @DEFAULT_SOURCE@ toggle)
;; previous first in playlist? <S-BS>?
;; make these support v:count? or should hyprland?
recognize (cmd bash -c "~/.config/hypr/scripts/recognize_song")
fx (cmd bash -c "~/.config/hypr/scripts/fx")
;; uppercase O for playlist?
loop (cmd bash -c "playerctl loop $( [ $(playerctl loop) = None ] && printf Track || printf None )")

;; needs mpv-mpris
back (cmd playerctl position 3-)
forward (cmd playerctl position 3+)
restart (cmd playerctl position 0)
)

(deflayer audio
  _
  _ _ _              _              _ _   _ _   _          _        @restart                  _ _ _
  _ _ _              _              _ _   _ _   @microphone          @loop      MediaTrackPrevious _
  _ _ _              @recognize            _ @fx _ @back VolumeDown VolumeUp @forward                _ _ _ _
  _ _ _              _              _ _   _ MediaTrackNext   VolumeMute _        _                  _ _
  _ _ _ MediaPlayPause _ _   _ _
  _ _ _             
)
#+end_src

** Blocked Layer
All keyboard input is blocked except the unlock combination (lctl + lmet + rsft).
Useful when passing your PC to someone else.

#+begin_src kbd
(deflayer blocked
  XX
  XX XX XX XX XX XX XX XX XX XX XX XX XX XX
  XX XX XX XX XX XX XX XX XX XX XX XX XX
  XX XX XX XX XX XX XX XX XX XX XX XX XX XX
  XX XX XX XX XX XX XX XX XX XX XX XX XX
  XX XX XX XX XX XX XX XX
  XX XX XX
)
#+end_src

** C-c Prefix Layer
This layer sends C-c before each key when activated by holding c with d (ctrl).
Keys support autoshift: tap=C-c <key>, hold=C-c <key>, long-hold=C-c S-<key>

#+begin_src kbd
;; Aliases for C-c prefix mappings with autoshift support
;; Pattern: tap=C-c key, hold=C-c key, long-hold=C-c Shift-key
(defalias
  cc-esc (tap-hold-press-timeout 175 175 (macro C-c esc) (macro C-c esc) (macro C-c S-esc))
  cc-grv (tap-hold-press-timeout 175 175 (macro C-c grv) (macro C-c grv) (macro C-c S-grv))
  cc-1 (tap-hold-press-timeout 175 175 (macro C-c Digit1) (macro C-c Digit1) (macro C-c S-1))
  cc-2 (tap-hold-press-timeout 175 175 (macro C-c Digit2) (macro C-c Digit2) (macro C-c S-2))
  cc-3 (tap-hold-press-timeout 175 175 (macro C-c Digit3) (macro C-c Digit3) (macro C-c S-3))
  cc-4 (tap-hold-press-timeout 175 175 (macro C-c Digit4) (macro C-c Digit4) (macro C-c S-4))
  cc-5 (tap-hold-press-timeout 175 175 (macro C-c Digit5) (macro C-c Digit5) (macro C-c S-5))
  cc-6 (tap-hold-press-timeout 175 175 (macro C-c Digit6) (macro C-c Digit6) (macro C-c S-6))
  cc-7 (tap-hold-press-timeout 175 175 (macro C-c Digit7) (macro C-c Digit7) (macro C-c S-7))
  cc-8 (tap-hold-press-timeout 175 175 (macro C-c Digit8) (macro C-c Digit8) (macro C-c S-8))
  cc-9 (tap-hold-press-timeout 175 175 (macro C-c Digit9) (macro C-c Digit9) (macro C-c S-9))
  cc-0 (tap-hold-press-timeout 175 175 (macro C-c Digit0) (macro C-c Digit0) (macro C-c S-0))
  cc-- (tap-hold-press-timeout 175 175 (macro C-c -) (macro C-c -) (macro C-c S--))
  cc-= (tap-hold-press-timeout 175 175 (macro C-c =) (macro C-c =) (macro C-c S-=))
  cc-bspc (tap-hold-press-timeout 175 175 (macro C-c bspc) (macro C-c bspc) (macro C-c S-bspc))
  cc-tab (tap-hold-press-timeout 175 175 (macro C-c tab) (macro C-c tab) (macro C-c S-tab))
  cc-q (tap-hold-press-timeout 175 175 (macro C-c q) (macro C-c q) (macro C-c S-q))
  cc-w (tap-hold-press-timeout 175 175 (macro C-c w) (macro C-c w) (macro C-c S-w))
  cc-e (tap-hold-press-timeout 175 175 (macro C-c e) (macro C-c e) (macro C-c S-e))
  cc-r (tap-hold-press-timeout 175 175 (macro C-c r) (macro C-c r) (macro C-c S-r))
  cc-t (tap-hold-press-timeout 175 175 (macro C-c t) (macro C-c t) (macro C-c S-t))
  cc-y (tap-hold-press-timeout 175 175 (macro C-c y) (macro C-c y) (macro C-c S-y))
  cc-u (tap-hold-press-timeout 175 175 (macro C-c u) (macro C-c u) (macro C-c S-u))
  cc-i (tap-hold-press-timeout 175 175 (macro C-c i) (macro C-c i) (macro C-c S-i))
  cc-o (tap-hold-press-timeout 175 175 (macro C-c o) (macro C-c o) (macro C-c S-o))
  cc-p (tap-hold-press-timeout 175 175 (macro C-c p) (macro C-c p) (macro C-c S-p))
  cc-[ (tap-hold-press-timeout 175 175 (macro C-c [) (macro C-c [) (macro C-c S-[))
  cc-] (tap-hold-press-timeout 175 175 (macro C-c ]) (macro C-c ]) (macro C-c S-]))
  cc-caps (tap-hold-press-timeout 175 175 (macro C-c caps) (macro C-c caps) (macro C-c S-caps))
  cc-a (tap-hold-press-timeout 175 175 (macro C-c a) (macro C-c a) (macro C-c S-a))
  cc-s (tap-hold-press-timeout 175 175 (macro C-c s) (macro C-c s) (macro C-c S-s))
  cc-d (tap-hold-press-timeout 175 175 (macro C-c d) (macro C-c d) (macro C-c S-d))
  cc-f (tap-hold-press-timeout 175 175 (macro C-c f) (macro C-c f) (macro C-c S-f))
  cc-g (tap-hold-press-timeout 175 175 (macro C-c g) (macro C-c g) (macro C-c S-g))
  cc-h (tap-hold-press-timeout 175 175 (macro C-c h) (macro C-c h) (macro C-c S-h))
  cc-j (tap-hold-press-timeout 175 175 (macro C-c j) (macro C-c j) (macro C-c S-j))
  cc-k (tap-hold-press-timeout 175 175 (macro C-c k) (macro C-c k) (macro C-c S-k))
  cc-l (tap-hold-press-timeout 175 175 (macro C-c l) (macro C-c l) (macro C-c S-l))
  cc-; (tap-hold-press-timeout 175 175 (macro C-c ;) (macro C-c ;) (macro C-c S-;))
  cc-' (tap-hold-press-timeout 175 175 (macro C-c ') (macro C-c ') (macro C-c S-'))
  cc-\ (tap-hold-press-timeout 175 175 (macro C-c \) (macro C-c \) (macro C-c S-\))
  cc-ret (tap-hold-press-timeout 175 175 (macro C-c ret) (macro C-c ret) (macro C-c S-ret))
  cc-lsft (tap-hold-press-timeout 175 175 (macro C-c lsft) (macro C-c lsft) (macro C-c S-lsft))
  cc-< (tap-hold-press-timeout 175 175 (macro C-c <) (macro C-c <) (macro C-c S-<))
  cc-z (tap-hold-press-timeout 175 175 (macro C-c z) (macro C-c z) (macro C-c S-z))
  cc-x (tap-hold-press-timeout 175 175 (macro C-c x) (macro C-c x) (macro C-c S-x))
  cc-c (tap-hold-press-timeout 175 175 (macro C-c c) (macro C-c c) (macro C-c S-c))
  cc-v (tap-hold-press-timeout 175 175 (macro C-c v) (macro C-c v) (macro C-c S-v))
  cc-b (tap-hold-press-timeout 175 175 (macro C-c b) (macro C-c b) (macro C-c S-b))
  cc-n (tap-hold-press-timeout 175 175 (macro C-c n) (macro C-c n) (macro C-c S-n))
  cc-m (tap-hold-press-timeout 175 175 (macro C-c m) (macro C-c m) (macro C-c S-m))
  cc-, (tap-hold-press-timeout 175 175 (macro C-c ,) (macro C-c ,) (macro C-c S-,))
  cc-. (tap-hold-press-timeout 175 175 (macro C-c .) (macro C-c .) (macro C-c S-.))
  cc-/ (tap-hold-press-timeout 175 175 (macro C-c /) (macro C-c /) (macro C-c S-/))
  cc-rsft (tap-hold-press-timeout 175 175 (macro C-c rsft) (macro C-c rsft) (macro C-c S-rsft))
  cc-lctl (tap-hold-press-timeout 175 175 (macro C-c lctl) (macro C-c lctl) (macro C-c S-lctl))
  cc-lmet (tap-hold-press-timeout 175 175 (macro C-c lmet) (macro C-c lmet) (macro C-c S-lmet))
  cc-lalt (tap-hold-press-timeout 175 175 (macro C-c lalt) (macro C-c lalt) (macro C-c S-lalt))
  cc-spc (tap-hold-press-timeout 175 175 (macro C-c spc) (macro C-c spc) (macro C-c S-spc))
  cc-ralt (tap-hold-press-timeout 175 175 (macro C-c ralt) (macro C-c ralt) (macro C-c S-ralt))
  cc-menu (tap-hold-press-timeout 175 175 (macro C-c menu) (macro C-c menu) (macro C-c S-menu))
  cc-prnt (tap-hold-press-timeout 175 175 (macro C-c prnt) (macro C-c prnt) (macro C-c S-prnt))
  cc-rctl (tap-hold-press-timeout 175 175 (macro C-c rctl) (macro C-c rctl) (macro C-c S-rctl))
  cc-mlft (tap-hold-press-timeout 175 175 (macro C-c mlft) (macro C-c mlft) (macro C-c S-mlft))
  cc-mmid (tap-hold-press-timeout 175 175 (macro C-c mmid) (macro C-c mmid) (macro C-c S-mmid))
  cc-mrgt (tap-hold-press-timeout 175 175 (macro C-c mrgt) (macro C-c mrgt) (macro C-c S-mrgt))
)

(deflayer c-c-prefix
  @cc-esc
  @cc-grv @cc-1 @cc-2 @cc-3 @cc-4 @cc-5 @cc-6 @cc-7 @cc-8 @cc-9 @cc-0 @cc-- @cc-= @cc-bspc
  @cc-tab @cc-q @cc-w @cc-e @cc-r @cc-t @cc-y @cc-u @cc-i @cc-o @cc-p @cc-[ @cc-]
  @cc-caps @cc-a @cc-s @cc-d @cc-f @cc-g @cc-h @cc-j @cc-k @cc-l @cc-; @cc-' @cc-\ @cc-ret
  @cc-lsft @cc-< @cc-z @cc-x @cc-c @cc-v @cc-b @cc-n @cc-m @cc-, @cc-. @cc-/ @cc-rsft
  @cc-lctl @cc-lmet @cc-lalt @cc-spc @cc-ralt @cc-menu @cc-prnt @cc-rctl
  @cc-mlft @cc-mmid @cc-mrgt
)
#+end_src

** C-c C-x Prefix Layer
This layer sends C-c C-x before each key when activated by pressing s in a-layer or l in semicolon-layer.
Keys support autoshift: tap=C-c C-x <key>, hold=C-c C-x <key>, long-hold=C-c C-x S-<key>

#+begin_src kbd
;; Aliases for C-c C-x prefix mappings with autoshift support
;; Pattern: tap=C-c C-x key, hold=C-c C-x key, long-hold=C-c C-x Shift-key
(defalias
  ccx-esc (tap-hold-press-timeout 175 175 (macro C-c C-x esc) (macro C-c C-x esc) (macro C-c C-x S-esc))
  ccx-grv (tap-hold-press-timeout 175 175 (macro C-c C-x grv) (macro C-c C-x grv) (macro C-c C-x S-grv))
  ccx-1 (tap-hold-press-timeout 175 175 (macro C-c C-x Digit1) (macro C-c C-x Digit1) (macro C-c C-x S-1))
  ccx-2 (tap-hold-press-timeout 175 175 (macro C-c C-x Digit2) (macro C-c C-x Digit2) (macro C-c C-x S-2))
  ccx-3 (tap-hold-press-timeout 175 175 (macro C-c C-x Digit3) (macro C-c C-x Digit3) (macro C-c C-x S-3))
  ccx-4 (tap-hold-press-timeout 175 175 (macro C-c C-x Digit4) (macro C-c C-x Digit4) (macro C-c C-x S-4))
  ccx-5 (tap-hold-press-timeout 175 175 (macro C-c C-x Digit5) (macro C-c C-x Digit5) (macro C-c C-x S-5))
  ccx-6 (tap-hold-press-timeout 175 175 (macro C-c C-x Digit6) (macro C-c C-x Digit6) (macro C-c C-x S-6))
  ccx-7 (tap-hold-press-timeout 175 175 (macro C-c C-x Digit7) (macro C-c C-x Digit7) (macro C-c C-x S-7))
  ccx-8 (tap-hold-press-timeout 175 175 (macro C-c C-x Digit8) (macro C-c C-x Digit8) (macro C-c C-x S-8))
  ccx-9 (tap-hold-press-timeout 175 175 (macro C-c C-x Digit9) (macro C-c C-x Digit9) (macro C-c C-x S-9))
  ccx-0 (tap-hold-press-timeout 175 175 (macro C-c C-x Digit0) (macro C-c C-x Digit0) (macro C-c C-x S-0))
  ccx-- (tap-hold-press-timeout 175 175 (macro C-c C-x -) (macro C-c C-x -) (macro C-c C-x S--))
  ccx-= (tap-hold-press-timeout 175 175 (macro C-c C-x =) (macro C-c C-x =) (macro C-c C-x S-=))
  ccx-bspc (tap-hold-press-timeout 175 175 (macro C-c C-x bspc) (macro C-c C-x bspc) (macro C-c C-x S-bspc))
  ccx-tab (tap-hold-press-timeout 175 175 (macro C-c C-x tab) (macro C-c C-x tab) (macro C-c C-x S-tab))
  ccx-q (tap-hold-press-timeout 175 175 (macro C-c C-x q) (macro C-c C-x q) (macro C-c C-x S-q))
  ccx-w (tap-hold-press-timeout 175 175 (macro C-c C-x w) (macro C-c C-x w) (macro C-c C-x S-w))
  ccx-e (tap-hold-press-timeout 175 175 (macro C-c C-x e) (macro C-c C-x e) (macro C-c C-x S-e))
  ccx-r (tap-hold-press-timeout 175 175 (macro C-c C-x r) (macro C-c C-x r) (macro C-c C-x S-r))
  ccx-t (tap-hold-press-timeout 175 175 (macro C-c C-x t) (macro C-c C-x t) (macro C-c C-x S-t))
  ccx-y (tap-hold-press-timeout 175 175 (macro C-c C-x y) (macro C-c C-x y) (macro C-c C-x S-y))
  ccx-u (tap-hold-press-timeout 175 175 (macro C-c C-x u) (macro C-c C-x u) (macro C-c C-x S-u))
  ccx-i (tap-hold-press-timeout 175 175 (macro C-c C-x i) (macro C-c C-x i) (macro C-c C-x S-i))
  ccx-o (tap-hold-press-timeout 175 175 (macro C-c C-x o) (macro C-c C-x o) (macro C-c C-x S-o))
  ccx-p (tap-hold-press-timeout 175 175 (macro C-c C-x p) (macro C-c C-x p) (macro C-c C-x S-p))
  ccx-[ (tap-hold-press-timeout 175 175 (macro C-c C-x [) (macro C-c C-x [) (macro C-c C-x S-[))
  ccx-] (tap-hold-press-timeout 175 175 (macro C-c C-x ]) (macro C-c C-x ]) (macro C-c C-x S-]))
  ccx-caps (tap-hold-press-timeout 175 175 (macro C-c C-x caps) (macro C-c C-x caps) (macro C-c C-x S-caps))
  ccx-a (tap-hold-press-timeout 175 175 (macro C-c C-x a) (macro C-c C-x a) (macro C-c C-x S-a))
  ccx-s (tap-hold-press-timeout 175 175 (macro C-c C-x s) (macro C-c C-x s) (macro C-c C-x S-s))
  ccx-d (tap-hold-press-timeout 175 175 (macro C-c C-x d) (layer-while-held c-c-x-ctrl) (macro C-c C-x S-d))
  ccx-f (tap-hold-press-timeout 175 175 (macro C-c C-x f) (macro C-c C-x f) (macro C-c C-x S-f))
  ccx-g (tap-hold-press-timeout 175 175 (macro C-c C-x g) (macro C-c C-x g) (macro C-c C-x S-g))
  ccx-h (tap-hold-press-timeout 175 175 (macro C-c C-x h) (macro C-c C-x h) (macro C-c C-x S-h))
  ccx-j (tap-hold-press-timeout 175 175 (macro C-c C-x j) (macro C-c C-x j) (macro C-c C-x S-j))
  ccx-k (tap-hold-press-timeout 175 175 (macro C-c C-x k) (layer-while-held c-c-x-ctrl) (macro C-c C-x S-k))
  ccx-l (tap-hold-press-timeout 175 175 (macro C-c C-x l) (macro C-c C-x l) (macro C-c C-x S-l))
  ccx-; (tap-hold-press-timeout 175 175 (macro C-c C-x ;) (macro C-c C-x ;) (macro C-c C-x S-;))
  ccx-' (tap-hold-press-timeout 175 175 (macro C-c C-x ') (macro C-c C-x ') (macro C-c C-x S-'))
  ccx-\ (tap-hold-press-timeout 175 175 (macro C-c C-x \) (macro C-c C-x \) (macro C-c C-x S-\))
  ccx-ret (tap-hold-press-timeout 175 175 (macro C-c C-x ret) (macro C-c C-x ret) (macro C-c C-x S-ret))
  ccx-lsft (tap-hold-press-timeout 175 175 (macro C-c C-x lsft) (macro C-c C-x lsft) (macro C-c C-x S-lsft))
  ccx-< (tap-hold-press-timeout 175 175 (macro C-c C-x <) (macro C-c C-x <) (macro C-c C-x S-<))
  ccx-z (tap-hold-press-timeout 175 175 (macro C-c C-x z) (macro C-c C-x z) (macro C-c C-x S-z))
  ccx-x (tap-hold-press-timeout 175 175 (macro C-c C-x x) (macro C-c C-x x) (macro C-c C-x S-x))
  ccx-c (tap-hold-press-timeout 175 175 (macro C-c C-x c) (macro C-c C-x c) (macro C-c C-x S-c))
  ccx-v (tap-hold-press-timeout 175 175 (macro C-c C-x v) (macro C-c C-x v) (macro C-c C-x S-v))
  ccx-b (tap-hold-press-timeout 175 175 (macro C-c C-x b) (macro C-c C-x b) (macro C-c C-x S-b))
  ccx-n (tap-hold-press-timeout 175 175 (macro C-c C-x n) (macro C-c C-x n) (macro C-c C-x S-n))
  ccx-m (tap-hold-press-timeout 175 175 (macro C-c C-x m) (macro C-c C-x m) (macro C-c C-x S-m))
  ccx-, (tap-hold-press-timeout 175 175 (macro C-c C-x ,) (macro C-c C-x ,) (macro C-c C-x S-,))
  ccx-. (tap-hold-press-timeout 175 175 (macro C-c C-x .) (macro C-c C-x .) (macro C-c C-x S-.))
  ccx-/ (tap-hold-press-timeout 175 175 (macro C-c C-x /) (macro C-c C-x /) (macro C-c C-x S-/))
  ccx-rsft (tap-hold-press-timeout 175 175 (macro C-c C-x rsft) (macro C-c C-x rsft) (macro C-c C-x S-rsft))
  ccx-lctl (tap-hold-press-timeout 175 175 (macro C-c C-x lctl) (macro C-c C-x lctl) (macro C-c C-x S-lctl))
  ccx-lmet (tap-hold-press-timeout 175 175 (macro C-c C-x lmet) (macro C-c C-x lmet) (macro C-c C-x S-lmet))
  ccx-lalt (tap-hold-press-timeout 175 175 (macro C-c C-x lalt) (macro C-c C-x lalt) (macro C-c C-x S-lalt))
  ccx-spc (tap-hold-press-timeout 175 175 (macro C-c C-x spc) (macro C-c C-x spc) (macro C-c C-x S-spc))
  ccx-ralt (tap-hold-press-timeout 175 175 (macro C-c C-x ralt) (macro C-c C-x ralt) (macro C-c C-x S-ralt))
  ccx-menu (tap-hold-press-timeout 175 175 (macro C-c C-x menu) (macro C-c C-x menu) (macro C-c C-x S-menu))
  ccx-prnt (tap-hold-press-timeout 175 175 (macro C-c C-x prnt) (macro C-c C-x prnt) (macro C-c C-x S-prnt))
  ccx-rctl (tap-hold-press-timeout 175 175 (macro C-c C-x rctl) (macro C-c C-x rctl) (macro C-c C-x S-rctl))
  ccx-mlft (tap-hold-press-timeout 175 175 (macro C-c C-x mlft) (macro C-c C-x mlft) (macro C-c C-x S-mlft))
  ccx-mmid (tap-hold-press-timeout 175 175 (macro C-c C-x mmid) (macro C-c C-x mmid) (macro C-c C-x S-mmid))
  ccx-mrgt (tap-hold-press-timeout 175 175 (macro C-c C-x mrgt) (macro C-c C-x mrgt) (macro C-c C-x S-mrgt))
)

(deflayer c-c-x-prefix
  @ccx-esc
  @ccx-grv @ccx-1 @ccx-2 @ccx-3 @ccx-4 @ccx-5 @ccx-6 @ccx-7 @ccx-8 @ccx-9 @ccx-0 @ccx-- @ccx-= @ccx-bspc
  @ccx-tab @ccx-q @ccx-w @ccx-e @ccx-r @ccx-t @ccx-y @ccx-u @ccx-i @ccx-o @ccx-p @ccx-[ @ccx-]
  @ccx-caps @ccx-a @ccx-s @ccx-d @ccx-f @ccx-g @ccx-h @ccx-j @ccx-k @ccx-l @ccx-; @ccx-' @ccx-\ @ccx-ret
  @ccx-lsft @ccx-< @ccx-z @ccx-x @ccx-c @ccx-v @ccx-b @ccx-n @ccx-m @ccx-, @ccx-. @ccx-/ @ccx-rsft
  @ccx-lctl @ccx-lmet @ccx-lalt @ccx-spc @ccx-ralt @ccx-menu @ccx-prnt @ccx-rctl
  @ccx-mlft @ccx-mmid @ccx-mrgt
)

;; Layer for C-c C-x C-<key> (activated when k is held in c-c-x-prefix layer)
;; This layer sends C-c C-x C-<key> for each key press
(deflayer c-c-x-ctrl
  _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ (macro C-c C-x C-q) (macro C-c C-x C-w) (macro C-c C-x C-e) (macro C-c C-x C-r) (macro C-c C-x C-t) (macro C-c C-x C-y) (macro C-c C-x C-u) (macro C-c C-x C-i) (macro C-c C-x C-o) (macro C-c C-x C-p) (macro C-c C-x C-[) (macro C-c C-x C-])
  _ (macro C-c C-x C-a) (macro C-c C-x C-s) (macro C-c C-x C-d) (macro C-c C-x C-f) (macro C-c C-x C-g) (macro C-c C-x C-h) (macro C-c C-x C-j) (macro C-c C-x C-k) (macro C-c C-x C-l) (macro C-c C-x C-;) (macro C-c C-x C-') (macro C-c C-x C-\) _
  _ _ (macro C-c C-x C-z) (macro C-c C-x C-x) (macro C-c C-x C-c) (macro C-c C-x C-v) (macro C-c C-x C-b) (macro C-c C-x C-n) (macro C-c C-x C-m) (macro C-c C-x C-,) (macro C-c C-x C-.) (macro C-c C-x C-/) _
  _ _ _ _ _ _ _ _
  _ _ _
)
#+end_src

** Left Ctrl Layer (d held)
This layer is activated when d is held. It acts like ctrl for all keys,
except s which triggers C-c C-x instead of C-s.

#+begin_src kbd
(deflayer left-ctrl-layer
  _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ (macro C-q) (macro C-w) (macro C-e) (macro C-r) (macro C-t) (macro C-y) (macro C-u) (macro C-i) (macro C-o) (macro C-p) (macro C-[) (macro C-])
  _ (macro C-a) (macro C-c C-x) (macro C-d) (macro C-f) (macro C-g) (macro C-h) (macro C-j) (macro C-k) (macro C-l) (macro C-;) (macro C-') (macro C-\) _
  _ _ (macro C-z) (macro C-x) (layer-while-held c-c-prefix) (macro C-v) (macro C-b) (macro C-n) (macro C-m) (macro C-,) (macro C-.) (macro C-/) _
  _ _ _ _ _ _ _ _
  _ _ _
)
#+end_src

** Right Ctrl Layer (k held)
This layer is activated when k is held. It acts like ctrl for all keys,
except l which triggers C-c C-x instead of C-l.

#+begin_src kbd
(deflayer right-ctrl-layer
  _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ (macro C-q) (macro C-w) (macro C-e) (macro C-r) (macro C-t) (macro C-y) (macro C-u) (macro C-i) (macro C-o) (macro C-p) (macro C-[) (macro C-])
  _ (macro C-a) (macro C-s) (macro C-d) (macro C-f) (macro C-g) (macro C-h) (macro C-j) (macro C-k) (macro C-c C-x) (macro C-;) (macro C-') (macro C-\) _
  _ _ (macro C-z) (macro C-x) (layer-while-held c-c-prefix) (macro C-v) (macro C-b) (macro C-n) (macro C-m) (macro C-,) (macro C-.) (macro C-/) _
  _ _ _ _ _ _ _ _
  _ _ _
)
#+end_src

** A Layer (a held)
This layer is activated when a is held. It sends f16 + key for all keys,
except s which activates c-c-x-prefix layer, and d/k which pass through to allow ctrl layer activation.

#+begin_src kbd
(deflayer a-layer
  _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ (tap-hold-press-timeout 175 175 (macro f16 q) (macro f16 q) (macro f16 S-q)) (tap-hold-press-timeout 175 175 (macro f16 w) (macro f16 w) (macro f16 S-w)) (tap-hold-press-timeout 175 175 (macro f16 e) (macro f16 e) (macro f16 S-e)) (tap-hold-press-timeout 175 175 (macro f16 r) (macro f16 r) (macro f16 S-r)) (tap-hold-press-timeout 175 175 (macro f16 t) (macro f16 t) (macro f16 S-t)) (tap-hold-press-timeout 175 175 (macro f16 y) (macro f16 y) (macro f16 S-y)) (tap-hold-press-timeout 175 175 (macro f16 u) (macro f16 u) (macro f16 S-u)) (tap-hold-press-timeout 175 175 (macro f16 i) (macro f16 i) (macro f16 S-i)) (tap-hold-press-timeout 175 175 (macro f16 o) (macro f16 o) (macro f16 S-o)) (tap-hold-press-timeout 175 175 (macro f16 p) (macro f16 p) (macro f16 S-p)) (tap-hold-press-timeout 175 175 (macro f16 [) (macro f16 [) (macro f16 S-[)) (tap-hold-press-timeout 175 175 (macro f16 ]) (macro f16 ]) (macro f16 S-]))
  _ (tap-hold-press-timeout 175 175 (macro f16 a) (macro f16 a) (macro f16 S-a)) (layer-while-held c-c-x-prefix) (tap-hold 175 175 (macro f16 d) (tap-hold-press-timeout 0 230 (macro f16 d) (layer-while-held left-ctrl-layer) (macro f16 S-d))) (tap-hold-press-timeout 175 175 (macro f16 f) (macro f16 f) (macro f16 S-f)) (tap-hold-press-timeout 175 175 (macro f16 g) (macro f16 g) (macro f16 S-g)) (tap-hold-press-timeout 175 175 (macro f16 h) (macro f16 h) (macro f16 S-h)) (tap-hold-press-timeout 175 175 (macro f16 j) (macro f16 j) (macro f16 S-j)) (tap-hold 175 175 (macro f16 k) (tap-hold-press-timeout 0 230 (macro f16 k) (layer-while-held right-ctrl-layer) (macro f16 S-k))) (tap-hold-press-timeout 150 175 (macro f16 l) (macro f16 f12) (macro f16 S-l)) (tap-hold-press-timeout 175 175 (macro f16 ;) (macro f16 ;) (macro f16 S-;)) (tap-hold-press-timeout 175 175 (macro f16 ') (macro f16 ') (macro f16 S-')) (tap-hold-press-timeout 175 175 (macro f16 \) (macro f16 \) (macro f16 S-\)) _
  _ _ (tap-hold-press-timeout 175 175 (macro f16 z) (macro f16 z) (macro f16 S-z)) (tap-hold-press-timeout 175 175 (macro f16 x) (macro f16 x) (macro f16 S-x)) (tap-hold-press-timeout 175 175 (macro f16 c) (macro f16 c) (macro f16 S-c)) (tap-hold-press-timeout 175 175 (macro f16 v) (macro f16 v) (macro f16 S-v)) (tap-hold-press-timeout 175 175 (macro f16 b) (macro f16 b) (macro f16 S-b)) (tap-hold-press-timeout 175 175 (macro f16 n) (macro f16 n) (macro f16 S-n)) (tap-hold-press-timeout 175 175 (macro f16 m) (macro f16 m) (macro f16 S-m)) (tap-hold-press-timeout 175 175 (macro f16 ,) (macro f16 ,) (macro f16 S-,)) (tap-hold-press-timeout 175 175 (macro f16 .) (macro f16 .) (macro f16 S-.)) (tap-hold-press-timeout 175 175 (macro f16 /) (macro f16 /) (macro f16 S-/)) _
  _ _ _ _ _ _ _ _
  _ _ _
)
#+end_src

** Semicolon Layer (; held)
This layer is activated when ; is held. It sends f16 + key for all keys,
except l which activates c-c-x-prefix layer, and d/k which pass through to allow ctrl layer activation.

#+begin_src kbd
(deflayer semicolon-layer
  _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ (tap-hold-press-timeout 175 175 (macro f16 q) (macro f16 q) (macro f16 S-q)) (tap-hold-press-timeout 175 175 (macro f16 w) (macro f16 w) (macro f16 S-w)) (tap-hold-press-timeout 175 175 (macro f16 e) (macro f16 e) (macro f16 S-e)) (tap-hold-press-timeout 175 175 (macro f16 r) (macro f16 r) (macro f16 S-r)) (tap-hold-press-timeout 175 175 (macro f16 t) (macro f16 t) (macro f16 S-t)) (tap-hold-press-timeout 175 175 (macro f16 y) (macro f16 y) (macro f16 S-y)) (tap-hold-press-timeout 175 175 (macro f16 u) (macro f16 u) (macro f16 S-u)) (tap-hold-press-timeout 175 175 (macro f16 i) (macro f16 i) (macro f16 S-i)) (tap-hold-press-timeout 175 175 (macro f16 o) (macro f16 o) (macro f16 S-o)) (tap-hold-press-timeout 175 175 (macro f16 p) (macro f16 p) (macro f16 S-p)) (tap-hold-press-timeout 175 175 (macro f16 [) (macro f16 [) (macro f16 S-[)) (tap-hold-press-timeout 175 175 (macro f16 ]) (macro f16 ]) (macro f16 S-]))
  _ (tap-hold-press-timeout 175 175 (macro f16 a) (macro f16 a) (macro f16 S-a)) (tap-hold-press-timeout 150 175 (macro f16 s) (macro f16 f12) (macro f16 S-s)) (tap-hold 175 175 (macro f16 d) (tap-hold-press-timeout 0 230 (macro f16 d) (layer-while-held left-ctrl-layer) (macro f16 S-d))) (tap-hold-press-timeout 175 175 (macro f16 f) (macro f16 f) (macro f16 S-f)) (tap-hold-press-timeout 175 175 (macro f16 g) (macro f16 g) (macro f16 S-g)) (tap-hold-press-timeout 175 175 (macro f16 h) (macro f16 h) (macro f16 S-h)) (tap-hold-press-timeout 175 175 (macro f16 j) (macro f16 j) (macro f16 S-j)) (tap-hold 175 175 (macro f16 k) (tap-hold-press-timeout 0 230 (macro f16 k) (layer-while-held right-ctrl-layer) (macro f16 S-k))) (layer-while-held c-c-x-prefix) (tap-hold-press-timeout 175 175 (macro f16 ;) (macro f16 ;) (macro f16 S-;)) (tap-hold-press-timeout 175 175 (macro f16 ') (macro f16 ') (macro f16 S-')) (tap-hold-press-timeout 175 175 (macro f16 \) (macro f16 \) (macro f16 S-\)) _
  _ _ (tap-hold-press-timeout 175 175 (macro f16 z) (macro f16 z) (macro f16 S-z)) (tap-hold-press-timeout 175 175 (macro f16 x) (macro f16 x) (macro f16 S-x)) (tap-hold-press-timeout 175 175 (macro f16 c) (macro f16 c) (macro f16 S-c)) (tap-hold-press-timeout 175 175 (macro f16 v) (macro f16 v) (macro f16 S-v)) (tap-hold-press-timeout 175 175 (macro f16 b) (macro f16 b) (macro f16 S-b)) (tap-hold-press-timeout 175 175 (macro f16 n) (macro f16 n) (macro f16 S-n)) (tap-hold-press-timeout 175 175 (macro f16 m) (macro f16 m) (macro f16 S-m)) (tap-hold-press-timeout 175 175 (macro f16 ,) (macro f16 ,) (macro f16 S-,)) (tap-hold-press-timeout 175 175 (macro f16 .) (macro f16 .) (macro f16 S-.)) (tap-hold-press-timeout 175 175 (macro f16 /) (macro f16 /) (macro f16 S-/)) _
  _ _ _ _ _ _ _ _
  _ _ _
)
#+end_src

* CHORDS
use also to toggle another layer
 purtroppo Chords legati a layout... qwerty (eventualmente adatta in base a prima letter premuta)
also use alt and altgr... (by themselves+chords)
 find unusual combinations lik hj/jh/etc... (also three (maybe more) letters like kl; ) (the letters don't have to be adiacent)
 double chord taps?
 how to repeat chords w/ rpt-any
 come usare autoshift keys here?
is it possible to do a tap-hold but for chords? for |...
 one finger only
~(n m) bspc 250 first-release ()~
#+begin_src kbd
(defchordsv2
;; (lsft rsft) lrld 250 first-release ()
;; use same mapping as :restart?
;;(f 5) lrld 250 first-release ()

;; would be nice if it worked with <C-h>
(lsft rsft) (caps-word 10000) 250 first-release ()

;;(mlft mrgt) rpt-any 250 first-release ()

;; Keyboard blocking toggle - useful when passing PC to others
;; (cmd pass blocked) @blocked-toggle 250 first-release ()

#+end_src

** Quick accents
In the future use picker like on phone?
(italian) accents (chords bcs vim digraphs kinda work like that)

#+begin_src kbd
(a caps)  (cmd bash -c "WAYLAND_DISPLAY=wayland-1 wtype √†") 100 first-release ()
(a ')  (cmd bash -c "WAYLAND_DISPLAY=wayland-1 wtype √°") 100 first-release ()

(e caps)  (cmd bash -c "WAYLAND_DISPLAY=wayland-1 wtype √®") 200 first-release ()
(e ')  (cmd bash -c "WAYLAND_DISPLAY=wayland-1 wtype √©") 100 first-release ()

(i caps)  (cmd bash -c "WAYLAND_DISPLAY=wayland-1 wtype √¨") 100 first-release ()
(i ')  (cmd bash -c "WAYLAND_DISPLAY=wayland-1 wtype √≠") 100 first-release ()

(o caps)  (cmd bash -c "WAYLAND_DISPLAY=wayland-1 wtype √≤") 100 first-release ()
(o ')  (cmd bash -c "WAYLAND_DISPLAY=wayland-1 wtype √≥") 100 first-release ()

(u caps)  (cmd bash -c "WAYLAND_DISPLAY=wayland-1 wtype √π") 100 first-release ()
(u ')  (cmd bash -c "WAYLAND_DISPLAY=wayland-1 wtype √∫") 100 first-release ()
)
#+end_src
